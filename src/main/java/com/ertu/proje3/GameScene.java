/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package com.ertu.proje3;

import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Insets;
import java.util.ArrayList;
import javax.swing.JOptionPane;

/**
 *
 * @author ergul
 */
public class GameScene extends javax.swing.JFrame {

    /**
     * Creates new form GameScene
     */
    public GameScene(Player player1, Player player2 ) {
        initComponents();
        // Usernames are shown in the interface
        p1UnameLabel.setText(player1.getUsername());
        p1UnameLabel.setEnabled(true);
        p2UnameLabel.setText(player2.getUsername());
        p2UnameLabel.setEnabled(true);
        
        state = new GameState(player1, player2);
        // According to Othello rules, black player starts the game
        state.setCurrentPlayer(GameState.Turn.BLACK);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jSplitPane1 = new javax.swing.JSplitPane();
        controlPanel = new javax.swing.JPanel();
        sizeSpinner = new javax.swing.JSpinner();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        newGameButton = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        p1UnameLabel = new javax.swing.JLabel();
        p2UnameLabel = new javax.swing.JLabel();
        passButton = new javax.swing.JButton();
        jLabel4 = new javax.swing.JLabel();
        playerTurnLabel = new javax.swing.JLabel();
        endGameButton = new javax.swing.JButton();
        gamePanel = new javax.swing.JPanel();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        scoreBoardMenuItem = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        getContentPane().setLayout(new javax.swing.BoxLayout(getContentPane(), javax.swing.BoxLayout.LINE_AXIS));

        jSplitPane1.setDividerLocation(90);
        jSplitPane1.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);

        controlPanel.setBackground(new java.awt.Color(201, 199, 175));
        controlPanel.setPreferredSize(new java.awt.Dimension(400, 60));

        sizeSpinner.setModel(new javax.swing.SpinnerNumberModel(6, 6, 10, 2));

        jLabel1.setForeground(new java.awt.Color(0, 0, 0));
        jLabel1.setText("Player 1: ");

        jLabel2.setForeground(new java.awt.Color(0, 0, 0));
        jLabel2.setText("Player 2:");

        newGameButton.setText("New Game");
        newGameButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                newGameButtonActionPerformed(evt);
            }
        });

        jLabel3.setForeground(new java.awt.Color(0, 0, 0));
        jLabel3.setText("Size:");

        p1UnameLabel.setForeground(new java.awt.Color(0, 0, 0));
        p1UnameLabel.setText("jLabel4");
        p1UnameLabel.setEnabled(false);

        p2UnameLabel.setForeground(new java.awt.Color(0, 0, 0));
        p2UnameLabel.setText("jLabel5");
        p2UnameLabel.setEnabled(false);

        passButton.setText("Pass");
        passButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                passButtonActionPerformed(evt);
            }
        });

        jLabel4.setForeground(new java.awt.Color(0, 0, 0));
        jLabel4.setText("Current Turn:");

        playerTurnLabel.setForeground(new java.awt.Color(0, 0, 0));
        playerTurnLabel.setText("Black");

        endGameButton.setText("End Game");
        endGameButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                endGameButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout controlPanelLayout = new javax.swing.GroupLayout(controlPanel);
        controlPanel.setLayout(controlPanelLayout);
        controlPanelLayout.setHorizontalGroup(
            controlPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(controlPanelLayout.createSequentialGroup()
                .addContainerGap(44, Short.MAX_VALUE)
                .addGroup(controlPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(controlPanelLayout.createSequentialGroup()
                        .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(sizeSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(controlPanelLayout.createSequentialGroup()
                        .addComponent(jLabel4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(playerTurnLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(18, 56, Short.MAX_VALUE)
                .addGroup(controlPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(endGameButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(newGameButton, javax.swing.GroupLayout.DEFAULT_SIZE, 92, Short.MAX_VALUE)
                    .addComponent(passButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 52, Short.MAX_VALUE)
                .addGroup(controlPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(controlPanelLayout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addGap(18, 18, 18)
                        .addComponent(p1UnameLabel))
                    .addGroup(controlPanelLayout.createSequentialGroup()
                        .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(p2UnameLabel)))
                .addContainerGap(54, Short.MAX_VALUE))
        );
        controlPanelLayout.setVerticalGroup(
            controlPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(controlPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(controlPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(sizeSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(newGameButton)
                    .addComponent(jLabel1)
                    .addComponent(p1UnameLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(controlPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(controlPanelLayout.createSequentialGroup()
                        .addComponent(passButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(controlPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel4)
                            .addComponent(playerTurnLabel)
                            .addComponent(endGameButton))
                        .addGap(12, 12, 12))
                    .addGroup(controlPanelLayout.createSequentialGroup()
                        .addGap(20, 20, 20)
                        .addGroup(controlPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel2)
                            .addComponent(p2UnameLabel))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );

        jSplitPane1.setLeftComponent(controlPanel);

        gamePanel.setBackground(new java.awt.Color(111, 90, 108));

        javax.swing.GroupLayout gamePanelLayout = new javax.swing.GroupLayout(gamePanel);
        gamePanel.setLayout(gamePanelLayout);
        gamePanelLayout.setHorizontalGroup(
            gamePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 517, Short.MAX_VALUE)
        );
        gamePanelLayout.setVerticalGroup(
            gamePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 224, Short.MAX_VALUE)
        );

        jSplitPane1.setRightComponent(gamePanel);

        getContentPane().add(jSplitPane1);

        jMenu1.setText("Scoreboard");

        scoreBoardMenuItem.setText("Scoreboard");
        scoreBoardMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                scoreBoardMenuItemActionPerformed(evt);
            }
        });
        jMenu1.add(scoreBoardMenuItem);

        jMenuBar1.add(jMenu1);

        setJMenuBar(jMenuBar1);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void newGameButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_newGameButtonActionPerformed
        gamePanel.removeAll();
        board_size = (Integer)sizeSpinner.getValue();
        buttons = new SquareButton[board_size][board_size];
        // Grid layout is used to imitate a game board. Space is specified as zero.
        gamePanel.setLayout(new GridLayout(board_size, board_size, 0, 0));
        Insets margin = new Insets(0, 0, 0, 0);
        // Board size is taken and a sufficient size is chosen for buttons so that they can be correctly resized
        Dimension panel_size = gamePanel.getSize();
        int button_size = (panel_size.width * panel_size.width) / board_size;
        for (int i = 0; i < board_size; i++) {
            for (int j = 0; j < board_size; j++) {
                SquareButton button = new SquareButton(button_size);
                button.setMargin(margin);
                button.addActionListener(new java.awt.event.ActionListener() {
                    @Override
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        squareButtonActionPerformed(evt);
                    }
                });
                button.setSize(64, 64);
                // Buttons' positions are recorded
                button.setPoint(i, j);
                buttons[i][j] = button;
                // Buton panele eklenir.
                gamePanel.add(button);
            }
        }
        
        // Initial stones are rendered.
        int board_half = board_size / 2;
        buttons[board_half - 1][board_half - 1].setHasCircle(true, false);
        buttons[board_half - 1][board_half - 1].setEnabled(false);
        buttons[board_half][board_half - 1].setHasCircle(true, true);
        buttons[board_half][board_half - 1].setEnabled(false);
        buttons[board_half - 1][board_half].setHasCircle(true, true);
        buttons[board_half - 1][board_half].setEnabled(false);
        buttons[board_half][board_half].setHasCircle(true, false);
        buttons[board_half][board_half].setEnabled(false);
        
        // Game starts with black player
        state.setCurrentPlayer(GameState.Turn.BLACK);
        
        gamePanel.revalidate();
        gamePanel.repaint();
    }//GEN-LAST:event_newGameButtonActionPerformed

    private void passButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_passButtonActionPerformed
        // Players manually pass their turn
        if (state.getCurrentPlayer() == GameState.Turn.BLACK) {
            state.setCurrentPlayer(GameState.Turn.WHITE);
            playerTurnLabel.setText("White");
        } else {
            state.setCurrentPlayer(GameState.Turn.BLACK);
            playerTurnLabel.setText("Black");
        }
    }//GEN-LAST:event_passButtonActionPerformed

    private void scoreBoardMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_scoreBoardMenuItemActionPerformed
        // This button shows the scoreboard.
        ScoreBoard board = new ScoreBoard(this, true, Database.getScores());
        board.setVisible(true);
    }//GEN-LAST:event_scoreBoardMenuItemActionPerformed

    private void endGameButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_endGameButtonActionPerformed
        // Players manually end the game. Their scores are recorded and the app is redirected to scoreboard
        int black_score = getColoredPoints(GameState.Turn.BLACK);
        int white_score = getColoredPoints(GameState.Turn.WHITE);
        Database.registerScore(state.getBlackPlayer(), black_score);
        Database.registerScore(state.getWhitePlayer(), white_score);
        
        ScoreBoard board = new ScoreBoard(null, false, Database.getScores());
        board.setVisible(true);
        this.dispose();
    }//GEN-LAST:event_endGameButtonActionPerformed

    private void squareButtonActionPerformed(java.awt.event.ActionEvent evt) {
        // Button that passed the event is retrieved.
        SquareButton button = (SquareButton)evt.getSource();
        // Board is checked to see if the player made a move.
        boolean moved = false;
        if (state.getCurrentPlayer() == GameState.Turn.BLACK) {
            // Upper direction is checked. If the move is valid, all the stones between - including
            // the positions - are rendered with the player's color
            Position upper_point = checkUp(button, GameState.Turn.BLACK);
            if (upper_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), upper_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, false);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            // Lower direction, same as the above. From now on only the directions change:
            // upper, lower, left, right, upper left, upper right, lower left, lower right.
            Position lower_point = checkDown(button, GameState.Turn.BLACK);
            if (lower_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), lower_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, false);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position left_point = checkLeft(button, GameState.Turn.BLACK);
            if (left_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), left_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, false);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position right_point = checkRight(button, GameState.Turn.BLACK);
            if (right_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), right_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, false);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position upper_left_point = checkUpperLeft(button, GameState.Turn.BLACK);
            if (upper_left_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), upper_left_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, false);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position upper_right_point = checkUpperRight(button, GameState.Turn.BLACK);
            if (upper_right_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), upper_right_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, false);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position lower_left_point = checkLowerLeft(button, GameState.Turn.BLACK);
            if (lower_left_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), lower_left_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, false);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position lower_right_point = checkLowerRight(button, GameState.Turn.BLACK);
            if (lower_right_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), lower_right_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, false);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            // If the player moved...
            if (moved) {
                // Opposite player is checked for valid moves
                if (testPlayerTurn(GameState.Turn.WHITE)) {
                    // If they can make a move, they get the next turn
                    state.setCurrentPlayer(GameState.Turn.WHITE);
                    playerTurnLabel.setText("White");
                } else if (!testPlayerTurn(GameState.Turn.WHITE) && testPlayerTurn(GameState.Turn.BLACK)) {
                    // But if the opposite player can't make a move while the current player can, they preserve the turn.
                    JOptionPane.showMessageDialog(this, "Opponent player doesn't have a valid move. Turn will not change",
                            "Player keeps turn", JOptionPane.INFORMATION_MESSAGE);
                } else {
                    // If both sides are unable to make a move, then game ends. Scores are recorded.
                    JOptionPane.showMessageDialog(this, "Players don't have valid moves. Ending the game with current scores...", "Game Over",
                            JOptionPane.INFORMATION_MESSAGE);
                    int black_score = getColoredPoints(GameState.Turn.BLACK);
                    int white_score = getColoredPoints(GameState.Turn.WHITE);
                    Database.registerScore(state.getBlackPlayer(), black_score);
                    Database.registerScore(state.getWhitePlayer(), white_score);
                }
            } else {
                // Fakat bu pozisyonda yapılabilen bir hamle yoksa hamlenin geçersiz olduğu
                // oyuncuya bildirilir.
                JOptionPane.showMessageDialog(this, "You can't play that square!",
                        "Invalid move", JOptionPane.ERROR_MESSAGE);
            }
        } else {
            // Vice versa for white player
            Position upper_point = checkUp(button, GameState.Turn.WHITE);
            if (upper_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), upper_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, true);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position lower_point = checkDown(button, GameState.Turn.WHITE);
            if (lower_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), lower_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, true);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position left_point = checkLeft(button, GameState.Turn.WHITE);
            if (left_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), left_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, true);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position right_point = checkRight(button, GameState.Turn.WHITE);
            if (right_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), right_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, true);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position upper_left_point = checkUpperLeft(button, GameState.Turn.WHITE);
            if (upper_left_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), upper_left_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, true);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position upper_right_point = checkUpperRight(button, GameState.Turn.WHITE);
            if (upper_right_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), upper_right_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, true);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position lower_left_point = checkLowerLeft(button, GameState.Turn.WHITE);
            if (lower_left_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), lower_left_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, true);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position lower_right_point = checkLowerRight(button, GameState.Turn.WHITE);
            if (lower_right_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), lower_right_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, true);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            if (moved) {    
                if (testPlayerTurn(GameState.Turn.BLACK)) {
                    state.setCurrentPlayer(GameState.Turn.BLACK);
                    playerTurnLabel.setText("Black");
                } else if (!testPlayerTurn(GameState.Turn.BLACK) && testPlayerTurn(GameState.Turn.WHITE)) {
                    JOptionPane.showMessageDialog(this, "Opponent player doesn't have a valid move. Turn will not change",
                            "Player keeps turn", JOptionPane.INFORMATION_MESSAGE);
                } else {
                    JOptionPane.showMessageDialog(this, "Players don't have valid moves. Ending the game with current scores...", "Game Over",
                            JOptionPane.INFORMATION_MESSAGE);
                    int black_score = getColoredPoints(GameState.Turn.BLACK);
                    int white_score = getColoredPoints(GameState.Turn.WHITE);
                    Database.registerScore(state.getBlackPlayer(), black_score);
                    Database.registerScore(state.getWhitePlayer(), white_score);
                }
            } else {
                JOptionPane.showMessageDialog(this, "You can't play that square!",
                        "Invalid move", JOptionPane.ERROR_MESSAGE);
            }
        }
        
        
    }
    
    private Position checkUp(SquareButton button, GameState.Turn player) {
        int x = button.getPoint().getX();
        int y = button.getPoint().getY();
        
        SquareButton last_button = null;    
        // The stone shouldn't be in the uppermost row.
        if (y != 0) {
            // Eğer oyuncu siyah ise...
            if (player == GameState.Turn.BLACK) {
                // Matrix is iterated downwards in y-axis while x-axis is constant
                for (int i = y - 1; i >= 0; i--) {
                    last_button = buttons[x][i];
                    int color = last_button.isFilled();
                    if (color == 0) { 
                        return null;
                    } else if (color == 1) { 
                        // Distance is checked because stones in same colour can't be placed side by side
                        int distance = Math.abs(y - last_button.getPoint().getY());
                        if (distance > 1) {
                            return last_button.getPoint();
                        }
                    }
                }
            } else {
                // Vice-versa for white player
                for (int i = x - 1; i >= 0; i--) {
                    last_button = buttons[x][i];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 2) {
                        int distance = Math.abs(y - last_button.getPoint().getY());
                        if (distance > 1) {
                            return last_button.getPoint();
                        }
                    }
                }
            }
        }
        return null;
    }
    
    // Difference from checkUp is that stone shouldn't be in lowermost row and matrix is iterated downwards
    private Position checkDown(SquareButton button, GameState.Turn player) {
        int x = button.getPoint().getX();
        int y = button.getPoint().getY();
        
        SquareButton last_button = null;
        if (y != board_size - 1) {
            if (player == GameState.Turn.BLACK) {
                for (int i = y + 1; i < board_size; i++) {
                    last_button = buttons[x][i];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 1) {
                        int distance = Math.abs(y - last_button.getPoint().getY());
                        if (distance > 1) {
                            return last_button.getPoint();
                        }
                    }
                }
            } else {
                for (int i = y + 1; i < board_size; i++) {
                    last_button = buttons[x][i];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 2) {
                        int distance = Math.abs(y - last_button.getPoint().getY());
                        if (distance > 1) {
                            return last_button.getPoint();
                        }
                    }
                }
            }
        }
        return null;
    }
    
    
    // Stone shouldn't be in leftmost column and matrix is iterated to the left while y-axis is constant.
    private Position checkLeft(SquareButton button, GameState.Turn player) {
        int x = button.getPoint().getX();
        int y = button.getPoint().getY();
        
        SquareButton last_button = null;
        if (x != 0) {
            if (player == GameState.Turn.BLACK) {
                for (int i = x - 1; i >= 0; i--) {
                    last_button = buttons[i][y];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 1) {
                        int distance = Math.abs(x - last_button.getPoint().getX());
                        if (distance > 1) {
                            return last_button.getPoint();
                        }
                    }
                }
            } else {
                for (int i = x - 1; i >= 0; i--) {
                    last_button = buttons[i][y];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 2) {
                        int distance = Math.abs(x - last_button.getPoint().getX());
                        if (distance > 1) {
                            return last_button.getPoint();
                        }
                    }
                }
            }
        }
        return null;
    }
    
    // y-axis is constant and matrix is iterated to the right. Stone shouldn't be in rightmost column.
    private Position checkRight(SquareButton button, GameState.Turn player) {
        int x = button.getPoint().getX();
        int y = button.getPoint().getY();
        
        SquareButton last_button = null;
        if (x != board_size - 1) {
            if (player == GameState.Turn.BLACK) {
                for (int i = x + 1; i < board_size; i++) {
                    last_button = buttons[i][y];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 1) {
                        int distance = Math.abs(x - last_button.getPoint().getX());
                        if (distance > 1) {
                            return last_button.getPoint();
                        }
                    }
                }
            } else {
                for (int i = y + 1; i < board_size; i++) {
                    last_button = buttons[i][y];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 2) {
                        int distance = Math.abs(x - last_button.getPoint().getX());
                        if (distance > 1) {
                            return last_button.getPoint();
                        }
                    }
                }
            }
        }
        return null;
    }
    
    
    // Matrix is iterated upwards and to the left. Stone shouldn't be in leftmost-highest position
    private Position checkUpperLeft(SquareButton button, GameState.Turn player) {
        int x = button.getPoint().getX();
        int y = button.getPoint().getY();
        
        SquareButton last_button = null;
        if (x != 0 && y !=0) {
            if (player == GameState.Turn.BLACK) {
                for (int i = x - 1, j = y - 1; i >= 0 && j >= 0; i--, j--) {
                    last_button = buttons[i][j];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 2) {
                        int distance = Math.abs(x - last_button.getPoint().getX()) + Math.abs(y - last_button.getPoint().getY());
                        if (distance > 2) {
                            return last_button.getPoint();
                        }
                    }
                }
            } else {
                for (int i = x - 1, j = y - 1; i >= 0 && j >= 0; i--, j--) {
                    last_button = buttons[i][j];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 2) {
                        int distance = Math.abs(x - last_button.getPoint().getX()) + Math.abs(y - last_button.getPoint().getY());
                        if (distance > 2) {
                            return last_button.getPoint();
                        }
                    }
                }
            }
        }
        return null;
    }
    
    // Matrix is iterated upwards and to the right. Stone shouldn't be in rightmost-highest position
    private Position checkUpperRight(SquareButton button, GameState.Turn player) {
        int x = button.getPoint().getX();
        int y = button.getPoint().getY();
        
        SquareButton last_button = null;
        if (x != board_size - 1 && y != 0) {
            if (player == GameState.Turn.BLACK) {
                for (int i = x + 1, j = y - 1; i >= 0 && j < board_size; i++, j--) {
                    last_button = buttons[i][j];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 1) {
                        int distance = Math.abs(x - last_button.getPoint().getX()) + Math.abs(y - last_button.getPoint().getY());
                        if (distance > 2) {
                            return last_button.getPoint();
                        }
                    }
                }
            } else {
                for (int i = x - 1, j = y + 1; i >= 0 && j < board_size; i--, j++) {
                    last_button = buttons[i][j];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 2) {
                        int distance = Math.abs(x - last_button.getPoint().getX()) + Math.abs(y - last_button.getPoint().getY());
                        if (distance > 2) {
                            return last_button.getPoint();
                        }
                    }
                }
            }
        }
        return null;
    }
    
    // Matrix is iterated downwars and to the right. Stone shouldn't be in rightmost-lowest position
    private Position checkLowerRight(SquareButton button, GameState.Turn player) {
        int x = button.getPoint().getX();
        int y = button.getPoint().getY();
        
        SquareButton last_button = null;
        if (y != board_size - 1) {
            if (player == GameState.Turn.BLACK) {
                for (int i = x + 1, j = y + 1; i < board_size && j < board_size; i++, j++) {
                    last_button = buttons[i][j];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 1) {
                        int distance = Math.abs(x - last_button.getPoint().getX()) + Math.abs(y - last_button.getPoint().getY());
                        if (distance > 2) {
                            return last_button.getPoint();
                        }
                    }
                }
            } else {
                for (int i = x + 1, j = y + 1; i < board_size && j < board_size; i++, j++) {
                    last_button = buttons[i][j];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 2) {
                        int distance = Math.abs(x - last_button.getPoint().getX()) + Math.abs(y - last_button.getPoint().getY());
                        if (distance > 2) {
                            return last_button.getPoint();
                        }
                    }
                }
            }
        }
        return null;
    }
    
    // Matrix is iterated downwards and to the left. Stone shouldn't be in leftmost-lowest position
    private Position checkLowerLeft(SquareButton button, GameState.Turn player) {
        int x = button.getPoint().getX();
        int y = button.getPoint().getY();
        
        SquareButton last_button;
        if (y != board_size - 1) {
            if (player == GameState.Turn.BLACK) {
                for (int i = x - 1, j = y + 1; i >= 0 && j < board_size; i--, j++) {
                    last_button = buttons[i][j];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 1) {
                        int distance = Math.abs(x - last_button.getPoint().getX()) + Math.abs(y - last_button.getPoint().getY());
                        if (distance > 2) {
                            return last_button.getPoint();
                        }
                    }
                }
            } else {
                for (int i = x - 1, j = y + 1; i >= 0 && j < board_size; i--, j++) {
                    last_button = buttons[i][j];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 2) {
                        int distance = Math.abs(x - last_button.getPoint().getX()) + Math.abs(y - last_button.getPoint().getY());
                        if (distance > 2) {
                            return last_button.getPoint();
                        }
                    }
                }
            }
        }
        return null;
    }
    
    // Player is tested if they can make a move
    private boolean testPlayerTurn(GameState.Turn player) {
        for (int i = 0; i < board_size; i++) {
            for (int j = 0; j < board_size; j++) {
                SquareButton button = buttons[i][j];
                if (checkUp(button, player) != null || checkDown(button, player) != null
                        || checkLeft(button, player) != null || checkRight(button, player) != null
                        || checkUpperLeft(button, player) != null || checkUpperRight(button, player) != null
                        || checkLowerLeft(button, player) != null || checkLowerRight(button, player) != null) {
                    return true;
                }
            }
        }
        return false;
    }
    
    // Black and white score counts are retrieved for scores
    private int getColoredPoints(GameState.Turn player) {
        int score = 0;
        
        if (player == GameState.Turn.BLACK) {
            for (int i = 0; i < board_size; i++) {
                for (int j = 0; j < board_size; j++) {
                    int color = buttons[i][j].isFilled();
                    if (color == 1) {
                        score++;
                    }
                }
            }
        } else {
            for (int i = 0; i < board_size; i++) {
                for (int j = 0; j < board_size; j++) {
                    int color = buttons[i][j].isFilled();
                    if (color == 2) {
                        score++;
                    }
                }
            }
        }
        return score;
    }
    
    private GameState state;
    private SquareButton[][] buttons;
    private int board_size;
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel controlPanel;
    private javax.swing.JButton endGameButton;
    private javax.swing.JPanel gamePanel;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JButton newGameButton;
    private javax.swing.JLabel p1UnameLabel;
    private javax.swing.JLabel p2UnameLabel;
    private javax.swing.JButton passButton;
    private javax.swing.JLabel playerTurnLabel;
    private javax.swing.JMenuItem scoreBoardMenuItem;
    private javax.swing.JSpinner sizeSpinner;
    // End of variables declaration//GEN-END:variables
}
