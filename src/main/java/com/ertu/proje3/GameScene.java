/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package com.ertu.proje3;

import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Insets;
import java.util.ArrayList;
import javax.swing.JOptionPane;

/**
 *
 * @author ergul
 */
public class GameScene extends javax.swing.JFrame {

    /**
     * Creates new form GameScene
     */
    public GameScene(Player player1, Player player2 ) {
        initComponents();
        p1UnameLabel.setText(player1.getUsername());
        p1UnameLabel.setEnabled(true);
        p2UnameLabel.setText(player2.getUsername());
        p2UnameLabel.setEnabled(true);
        
        state = new GameState(player1, player2);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jSplitPane1 = new javax.swing.JSplitPane();
        controlPanel = new javax.swing.JPanel();
        sizeSpinner = new javax.swing.JSpinner();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        newGameButton = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        p1UnameLabel = new javax.swing.JLabel();
        p2UnameLabel = new javax.swing.JLabel();
        passButton = new javax.swing.JButton();
        jLabel4 = new javax.swing.JLabel();
        playerTurnLabel = new javax.swing.JLabel();
        gamePanel = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        getContentPane().setLayout(new javax.swing.BoxLayout(getContentPane(), javax.swing.BoxLayout.LINE_AXIS));

        jSplitPane1.setDividerLocation(65);
        jSplitPane1.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);

        controlPanel.setBackground(new java.awt.Color(201, 199, 175));
        controlPanel.setPreferredSize(new java.awt.Dimension(400, 60));

        sizeSpinner.setModel(new javax.swing.SpinnerNumberModel(6, 6, 10, 2));

        jLabel1.setForeground(new java.awt.Color(0, 0, 0));
        jLabel1.setText("Player 1: ");

        jLabel2.setForeground(new java.awt.Color(0, 0, 0));
        jLabel2.setText("Player 2:");

        newGameButton.setText("New Game");
        newGameButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                newGameButtonActionPerformed(evt);
            }
        });

        jLabel3.setForeground(new java.awt.Color(0, 0, 0));
        jLabel3.setText("Size:");

        p1UnameLabel.setForeground(new java.awt.Color(0, 0, 0));
        p1UnameLabel.setText("jLabel4");
        p1UnameLabel.setEnabled(false);

        p2UnameLabel.setForeground(new java.awt.Color(0, 0, 0));
        p2UnameLabel.setText("jLabel5");
        p2UnameLabel.setEnabled(false);

        passButton.setText("Pass");
        passButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                passButtonActionPerformed(evt);
            }
        });

        jLabel4.setForeground(new java.awt.Color(0, 0, 0));
        jLabel4.setText("Current Turn:");

        playerTurnLabel.setForeground(new java.awt.Color(0, 0, 0));
        playerTurnLabel.setText("Black");

        javax.swing.GroupLayout controlPanelLayout = new javax.swing.GroupLayout(controlPanel);
        controlPanel.setLayout(controlPanelLayout);
        controlPanelLayout.setHorizontalGroup(
            controlPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(controlPanelLayout.createSequentialGroup()
                .addContainerGap(14, Short.MAX_VALUE)
                .addGroup(controlPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(controlPanelLayout.createSequentialGroup()
                        .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(sizeSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(controlPanelLayout.createSequentialGroup()
                        .addComponent(jLabel4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(playerTurnLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(18, 27, Short.MAX_VALUE)
                .addGroup(controlPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(newGameButton, javax.swing.GroupLayout.DEFAULT_SIZE, 92, Short.MAX_VALUE)
                    .addComponent(passButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 23, Short.MAX_VALUE)
                .addGroup(controlPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(controlPanelLayout.createSequentialGroup()
                        .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(p2UnameLabel))
                    .addGroup(controlPanelLayout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addGap(18, 18, 18)
                        .addComponent(p1UnameLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addContainerGap(25, Short.MAX_VALUE))
        );
        controlPanelLayout.setVerticalGroup(
            controlPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, controlPanelLayout.createSequentialGroup()
                .addGap(0, 6, Short.MAX_VALUE)
                .addGroup(controlPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(newGameButton)
                    .addComponent(p1UnameLabel))
                .addGap(5, 5, 5)
                .addGroup(controlPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(p2UnameLabel))
                .addGap(15, 15, 15))
            .addGroup(controlPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(controlPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(sizeSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(controlPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(passButton)
                    .addGroup(controlPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jLabel4)
                        .addComponent(playerTurnLabel)))
                .addGap(0, 0, Short.MAX_VALUE))
        );

        jSplitPane1.setLeftComponent(controlPanel);

        gamePanel.setBackground(new java.awt.Color(111, 90, 108));

        javax.swing.GroupLayout gamePanelLayout = new javax.swing.GroupLayout(gamePanel);
        gamePanel.setLayout(gamePanelLayout);
        gamePanelLayout.setHorizontalGroup(
            gamePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        gamePanelLayout.setVerticalGroup(
            gamePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 229, Short.MAX_VALUE)
        );

        jSplitPane1.setRightComponent(gamePanel);

        getContentPane().add(jSplitPane1);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void newGameButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_newGameButtonActionPerformed
        gamePanel.removeAll();
        board_size = (Integer)sizeSpinner.getValue();
        buttons = new SquareButton[board_size][board_size];
        gamePanel.setLayout(new GridLayout(board_size, board_size, 0, 0));
        Insets margin = new Insets(0, 0, 0, 0);
        Dimension panel_size = gamePanel.getSize();
        int button_size = (panel_size.width * panel_size.width) / board_size;
        for (int i = 0; i < board_size; i++) {
            for (int j = 0; j < board_size; j++) {
                SquareButton button = new SquareButton(button_size);
                button.setMargin(margin);
                button.addActionListener(new java.awt.event.ActionListener() {
                    @Override
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        squareButtonActionPerformed(evt);
                    }
                });
                button.setSize(64, 64);
                //button.setEnabled(false);
                button.setPoint(i, j);
                buttons[i][j] = button;
                gamePanel.add(button);
            }
        }
        
        int board_half = board_size / 2;
        buttons[board_half - 1][board_half - 1].setHasCircle(true, false);
        buttons[board_half - 1][board_half - 1].setEnabled(false);
        buttons[board_half][board_half - 1].setHasCircle(true, true);
        buttons[board_half][board_half - 1].setEnabled(false);
        buttons[board_half - 1][board_half].setHasCircle(true, true);
        buttons[board_half - 1][board_half].setEnabled(false);
        buttons[board_half][board_half].setHasCircle(true, false);
        buttons[board_half][board_half].setEnabled(false);
        
        gamePanel.revalidate();
        gamePanel.repaint();
    }//GEN-LAST:event_newGameButtonActionPerformed

    private void passButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_passButtonActionPerformed
        if (state.getCurrentPlayer() == GameState.Turn.BLACK) {
            state.setCurrentPlayer(GameState.Turn.WHITE);
            playerTurnLabel.setText("White");
        } else {
            state.setCurrentPlayer(GameState.Turn.BLACK);
            playerTurnLabel.setText("Black");
        }
    }//GEN-LAST:event_passButtonActionPerformed

    private void squareButtonActionPerformed(java.awt.event.ActionEvent evt) {
        SquareButton button = (SquareButton)evt.getSource();
        boolean moved = false;
        if (state.getCurrentPlayer() == GameState.Turn.BLACK) {
            Position upper_point = checkUp(button, GameState.Turn.BLACK);
            if (upper_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), upper_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, false);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position lower_point = checkDown(button, GameState.Turn.BLACK);
            if (lower_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), lower_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, false);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position left_point = checkLeft(button, GameState.Turn.BLACK);
            if (left_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), left_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, false);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position right_point = checkRight(button, GameState.Turn.BLACK);
            if (right_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), right_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, false);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position upper_left_point = checkUpperLeft(button, GameState.Turn.BLACK);
            if (upper_left_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), upper_left_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, false);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position upper_right_point = checkUpperRight(button, GameState.Turn.BLACK);
            if (upper_right_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), upper_right_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, false);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position lower_left_point = checkLowerLeft(button, GameState.Turn.BLACK);
            if (lower_left_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), lower_left_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, false);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position lower_right_point = checkLowerRight(button, GameState.Turn.BLACK);
            if (lower_right_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), lower_right_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, false);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            if (moved) {
                if (testPlayerTurn(GameState.Turn.WHITE)) {
                    state.setCurrentPlayer(GameState.Turn.WHITE);
                    playerTurnLabel.setText("White");
                } else if (!testPlayerTurn(GameState.Turn.WHITE) && testPlayerTurn(GameState.Turn.BLACK)) {
                    JOptionPane.showMessageDialog(this, "Opponent player doesn't have a valid move. Turn will not change",
                            "Player keeps turn", JOptionPane.INFORMATION_MESSAGE);
                } else {
                    JOptionPane.showMessageDialog(this, "Players don't have valid moves. Ending the game with current scores...", "Game Over",
                            JOptionPane.INFORMATION_MESSAGE);
                }
            } else {
                JOptionPane.showMessageDialog(this, "You can't play that square!",
                        "Invalid move", JOptionPane.ERROR_MESSAGE);
            }
        } else {
            Position upper_point = checkUp(button, GameState.Turn.WHITE);
            if (upper_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), upper_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, true);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position lower_point = checkDown(button, GameState.Turn.WHITE);
            if (lower_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), lower_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, true);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position left_point = checkLeft(button, GameState.Turn.WHITE);
            if (left_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), left_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, true);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position right_point = checkRight(button, GameState.Turn.WHITE);
            if (right_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), right_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, true);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position upper_left_point = checkUpperLeft(button, GameState.Turn.WHITE);
            if (upper_left_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), upper_left_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, true);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position upper_right_point = checkUpperRight(button, GameState.Turn.WHITE);
            if (upper_right_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), upper_right_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, true);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position lower_left_point = checkLowerLeft(button, GameState.Turn.WHITE);
            if (lower_left_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), lower_left_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, true);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            
            Position lower_right_point = checkLowerRight(button, GameState.Turn.WHITE);
            if (lower_right_point != null) {
                ArrayList<Position> path = Position.getPath(button.getPoint(), lower_right_point);
                for (Position point : path) {
                    buttons[point.getX()][point.getY()].setHasCircle(true, true);
                    buttons[point.getX()][point.getY()].setEnabled(false);
                }
                moved = true;
            }
            if (moved) {    
                if (testPlayerTurn(GameState.Turn.BLACK)) {
                    state.setCurrentPlayer(GameState.Turn.BLACK);
                    playerTurnLabel.setText("Black");
                } else if (!testPlayerTurn(GameState.Turn.BLACK) && testPlayerTurn(GameState.Turn.WHITE)) {
                    JOptionPane.showMessageDialog(this, "Opponent player doesn't have a valid move. Turn will not change",
                            "Player keeps turn", JOptionPane.INFORMATION_MESSAGE);
                } else {
                    JOptionPane.showMessageDialog(this, "Players don't have valid moves. Ending the game with current scores...", "Game Over",
                            JOptionPane.INFORMATION_MESSAGE);
                }
            } else {
                JOptionPane.showMessageDialog(this, "You can't play that square!",
                        "Invalid move", JOptionPane.ERROR_MESSAGE);
            }
        }
        
        
    }
    
    private Position checkUp(SquareButton button, GameState.Turn player) {
        int x = button.getPoint().getX();
        int y = button.getPoint().getY();
        
        SquareButton last_button = null;    
        if (y != 0) {
            if (player == GameState.Turn.BLACK) {
                for (int i = y - 1; i >= 0; i--) {
                    last_button = buttons[x][i];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 1) {
                        int distance = Math.abs(y - last_button.getPoint().getY());
                        if (distance > 1) {
                            return last_button.getPoint();
                        }
                    }
                }
            } else {
                for (int i = x - 1; i >= 0; i--) {
                    last_button = buttons[x][i];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 2) {
                        int distance = Math.abs(y - last_button.getPoint().getY());
                        if (distance > 1) {
                            return last_button.getPoint();
                        }
                    }
                }
            }
        }
        return null;
    }
    
    private Position checkDown(SquareButton button, GameState.Turn player) {
        int x = button.getPoint().getX();
        int y = button.getPoint().getY();
        
        SquareButton last_button = null;
        if (y != board_size - 1) {
            if (player == GameState.Turn.BLACK) {
                for (int i = y + 1; i < board_size; i++) {
                    last_button = buttons[x][i];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 1) {
                        int distance = Math.abs(y - last_button.getPoint().getY());
                        if (distance > 1) {
                            return last_button.getPoint();
                        }
                    }
                }
            } else {
                for (int i = y + 1; i < board_size; i++) {
                    last_button = buttons[x][i];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 2) {
                        int distance = Math.abs(y - last_button.getPoint().getY());
                        if (distance > 1) {
                            return last_button.getPoint();
                        }
                    }
                }
            }
        }
        return null;
    }
    
    private Position checkLeft(SquareButton button, GameState.Turn player) {
        int x = button.getPoint().getX();
        int y = button.getPoint().getY();
        
        SquareButton last_button = null;
        if (x != 0) {
            if (player == GameState.Turn.BLACK) {
                for (int i = x - 1; i >= 0; i--) {
                    last_button = buttons[i][y];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 1) {
                        int distance = Math.abs(x - last_button.getPoint().getX());
                        if (distance > 1) {
                            return last_button.getPoint();
                        }
                    }
                }
            } else {
                for (int i = x - 1; i >= 0; i--) {
                    last_button = buttons[i][y];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 2) {
                        int distance = Math.abs(x - last_button.getPoint().getX());
                        if (distance > 1) {
                            return last_button.getPoint();
                        }
                    }
                }
            }
        }
        return null;
    }
    
    private Position checkRight(SquareButton button, GameState.Turn player) {
        int x = button.getPoint().getX();
        int y = button.getPoint().getY();
        
        SquareButton last_button = null;
        if (x != board_size - 1) {
            if (player == GameState.Turn.BLACK) {
                for (int i = x + 1; i < board_size; i++) {
                    last_button = buttons[i][y];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 1) {
                        int distance = Math.abs(x - last_button.getPoint().getX());
                        if (distance > 1) {
                            return last_button.getPoint();
                        }
                    }
                }
            } else {
                for (int i = y + 1; i < board_size; i++) {
                    last_button = buttons[i][y];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 2) {
                        int distance = Math.abs(x - last_button.getPoint().getX());
                        if (distance > 1) {
                            return last_button.getPoint();
                        }
                    }
                }
            }
        }
        return null;
    }
    
    private Position checkUpperLeft(SquareButton button, GameState.Turn player) {
        int x = button.getPoint().getX();
        int y = button.getPoint().getY();
        
        SquareButton last_button = null;
        if (x != 0 && y !=0) {
            if (player == GameState.Turn.BLACK) {
                for (int i = x - 1, j = y - 1; i >= 0 && j >= 0; i--, j--) {
                    last_button = buttons[i][j];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 2) {
                        int distance = Math.abs(x - last_button.getPoint().getX()) + Math.abs(y - last_button.getPoint().getY());
                        if (distance > 2) {
                            return last_button.getPoint();
                        }
                    }
                }
            } else {
                for (int i = x - 1, j = y - 1; i >= 0 && j >= 0; i--, j--) {
                    last_button = buttons[i][j];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 2) {
                        int distance = Math.abs(x - last_button.getPoint().getX()) + Math.abs(y - last_button.getPoint().getY());
                        if (distance > 2) {
                            return last_button.getPoint();
                        }
                    }
                }
            }
        }
        return null;
    }
    
    private Position checkUpperRight(SquareButton button, GameState.Turn player) {
        int x = button.getPoint().getX();
        int y = button.getPoint().getY();
        
        SquareButton last_button = null;
        if (x != board_size - 1 && y != 0) {
            if (player == GameState.Turn.BLACK) {
                for (int i = x + 1, j = y - 1; i >= 0 && j < board_size; i++, j--) {
                    last_button = buttons[i][j];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 1) {
                        int distance = Math.abs(x - last_button.getPoint().getX()) + Math.abs(y - last_button.getPoint().getY());
                        if (distance > 2) {
                            return last_button.getPoint();
                        }
                    }
                }
            } else {
                for (int i = x - 1, j = y + 1; i >= 0 && j < board_size; i--, j++) {
                    last_button = buttons[i][j];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 2) {
                        int distance = Math.abs(x - last_button.getPoint().getX()) + Math.abs(y - last_button.getPoint().getY());
                        if (distance > 2) {
                            return last_button.getPoint();
                        }
                    }
                }
            }
        }
        return null;
    }
    
    private Position checkLowerRight(SquareButton button, GameState.Turn player) {
        int x = button.getPoint().getX();
        int y = button.getPoint().getY();
        
        SquareButton last_button = null;
        if (y != board_size - 1) {
            if (player == GameState.Turn.BLACK) {
                for (int i = x + 1, j = y + 1; i < board_size && j < board_size; i++, j++) {
                    last_button = buttons[i][j];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 1) {
                        int distance = Math.abs(x - last_button.getPoint().getX()) + Math.abs(y - last_button.getPoint().getY());
                        if (distance > 2) {
                            return last_button.getPoint();
                        }
                    }
                }
            } else {
                for (int i = x + 1, j = y + 1; i < board_size && j < board_size; i++, j++) {
                    last_button = buttons[i][j];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 2) {
                        int distance = Math.abs(x - last_button.getPoint().getX()) + Math.abs(y - last_button.getPoint().getY());
                        if (distance > 2) {
                            return last_button.getPoint();
                        }
                    }
                }
            }
        }
        return null;
    }
    
    private Position checkLowerLeft(SquareButton button, GameState.Turn player) {
        int x = button.getPoint().getX();
        int y = button.getPoint().getY();
        
        SquareButton last_button = null;
        if (y != board_size - 1) {
            if (player == GameState.Turn.BLACK) {
                for (int i = x - 1, j = y + 1; i >= 0 && j < board_size; i--, j++) {
                    last_button = buttons[i][j];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 1) {
                        int distance = Math.abs(x - last_button.getPoint().getX()) + Math.abs(y - last_button.getPoint().getY());
                        if (distance > 2) {
                            return last_button.getPoint();
                        }
                    }
                }
            } else {
                for (int i = x - 1, j = y + 1; i >= 0 && j < board_size; i--, j++) {
                    last_button = buttons[i][j];
                    int color = last_button.isFilled();
                    if (color == 0) {
                        return null;
                    } else if (color == 2) {
                        int distance = Math.abs(x - last_button.getPoint().getX()) + Math.abs(y - last_button.getPoint().getY());
                        if (distance > 2) {
                            return last_button.getPoint();
                        }
                    }
                }
            }
        }
        return null;
    }
    
    private boolean testPlayerTurn(GameState.Turn player) {
        for (int i = 0; i < board_size; i++) {
            for (int j = 0; j < board_size; j++) {
                SquareButton button = buttons[i][j];
                if (checkUp(button, player) != null || checkDown(button, player) != null
                        || checkLeft(button, player) != null || checkRight(button, player) != null
                        || checkUpperLeft(button, player) != null || checkUpperRight(button, player) != null
                        || checkLowerLeft(button, player) != null || checkLowerRight(button, player) != null) {
                    return true;
                }
            }
        }
        return false;
    }
    
    private GameState state;
    private SquareButton[][] buttons;
    private int board_size;
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel controlPanel;
    private javax.swing.JPanel gamePanel;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JButton newGameButton;
    private javax.swing.JLabel p1UnameLabel;
    private javax.swing.JLabel p2UnameLabel;
    private javax.swing.JButton passButton;
    private javax.swing.JLabel playerTurnLabel;
    private javax.swing.JSpinner sizeSpinner;
    // End of variables declaration//GEN-END:variables
}
